@startuml vista-procesos
' Vista de Procesos - Modelo 4+1
' Muestra los procesos concurrentes y la comunicaci√≥n entre ellos

!define ACTOR participant
!define COMPONENT participant

title Flujo de Procesos: Solicitud y Confirmaci√≥n de Sesi√≥n de Tutor√≠a

actor Estudiante as student
actor Tutor as tutor
actor Manager as manager

COMPONENT "Frontend\n(React SPA)" as frontend
COMPONENT "API Backend\n(Firebase Functions)" as api
COMPONENT "Auth Middleware" as auth
COMPONENT "Sessions Service" as sessionsvc
COMPONENT "Sessions Repo" as sessionrepo
COMPONENT "Notifications Service" as notifications
database "Firestore" as db
database "Firebase Auth" as fbauth

== Fase 1: Solicitud de Sesi√≥n por Estudiante ==

student -> frontend: Ingresa c√≥digo del tutor\ny solicita sesi√≥n
frontend -> fbauth: getIdToken()
fbauth --> frontend: JWT token
frontend -> api: POST /sessions/request\n{code, subject, date}\nAuthorization: Bearer <token>

api -> auth: verifyToken(token)
auth -> fbauth: verifyIdToken(token)
fbauth --> auth: DecodedToken + roles
auth --> api: req.user = {uid, roles}

api -> sessionsvc: requestSession(data, studentId)

par Concurrent Operations
  sessionsvc -> sessionrepo: getByCode(code)
  sessionrepo -> db: query tutors_codes\nwhere code = '1234'
  db --> sessionrepo: tutorInfo
  sessionrepo --> sessionsvc: tutorInfo

  sessionsvc -> sessionrepo: create({...sessionData})
  sessionrepo -> db: add to sessions collection
  db --> sessionrepo: sessionId
  sessionrepo --> sessionsvc: sessionId
end

sessionsvc -> notifications: notifyTutorSessionRequested(tutorId)
note right
  Notificaci√≥n as√≠ncrona (fire-and-forget)
  No bloquea la respuesta al estudiante
end note

notifications -> db: Get tutor FCM token
db --> notifications: fcm_token
notifications -> "FCM\n(Firebase Cloud Messaging)": Send push notification
"FCM\n(Firebase Cloud Messaging)" --> tutor: üì± Nueva solicitud de sesi√≥n

sessionsvc --> api: {id, status: "requested", ...}
api --> frontend: 201 Created\n{session}
frontend --> student: ‚úÖ Sesi√≥n solicitada exitosamente

== Fase 2: Confirmaci√≥n por Tutor ==

tutor -> frontend: Revisa solicitudes\ny confirma sesi√≥n
frontend -> fbauth: getIdToken()
fbauth --> frontend: JWT token
frontend -> api: POST /sessions/:id/confirm\n{scheduledAt}\nAuthorization: Bearer <token>

api -> auth: verifyToken(token)
auth -> fbauth: verifyIdToken(token)
fbauth --> auth: DecodedToken + roles
auth --> api: req.user = {uid, roles: ['tutor']}

api -> sessionsvc: confirmByTutor(sessionId, scheduledAt, tutorId)

sessionsvc -> sessionrepo: getById(sessionId)
sessionrepo -> db: get session document
db --> sessionrepo: session data
sessionrepo --> sessionsvc: session

alt Session validation
  sessionsvc -> sessionsvc: Validate session belongs to tutor
  sessionsvc -> sessionsvc: Validate status is "requested"
else Validation fails
  sessionsvc --> api: Error: Invalid session or status
  api --> frontend: 400 Bad Request
  frontend --> tutor: ‚ùå No se puede confirmar
  [end]
end

sessionsvc -> sessionrepo: update(sessionId, {status: "confirmed", scheduledAt})
sessionrepo -> db: update sessions/{sessionId}
db --> sessionrepo: updated session
sessionrepo --> sessionsvc: updatedSession

sessionsvc -> notifications: notifyStudentSessionConfirmed(studentId)
notifications -> db: Get student FCM token
db --> notifications: fcm_token
notifications -> "FCM\n(Firebase Cloud Messaging)": Send push notification
"FCM\n(Firebase Cloud Messaging)" --> student: üì± Sesi√≥n confirmada

sessionsvc --> api: {id, status: "confirmed", scheduledAt, ...}
api --> frontend: 200 OK\n{session}
frontend --> tutor: ‚úÖ Sesi√≥n confirmada

== Fase 3: Finalizaci√≥n de Sesi√≥n ==

student -> frontend: Marca sesi√≥n como completada
frontend -> api: POST /sessions/:id/mark-done\nAuthorization: Bearer <token>

api -> auth: verifyToken(token)
auth --> api: req.user

api -> sessionsvc: markDoneByStudent(sessionId, studentId)
sessionsvc -> sessionrepo: getById(sessionId)
sessionrepo -> db: get session document
db --> sessionrepo: session
sessionrepo --> sessionsvc: session

sessionsvc -> sessionsvc: Validate session belongs to student
sessionsvc -> sessionsvc: Validate status is "confirmed"

sessionsvc -> sessionrepo: update(sessionId, {status: "done", completedAt})
sessionrepo -> db: update sessions/{sessionId}
db --> sessionrepo: updated session
sessionrepo --> sessionsvc: updatedSession

sessionsvc --> api: {id, status: "done", ...}
api --> frontend: 200 OK\n{session}
frontend --> student: ‚úÖ Sesi√≥n completada

note over sessionsvc, sessionrepo
  **Concurrencia y Consistencia:**
  - Todas las operaciones de escritura en Firestore
    son at√≥micas
  - Las notificaciones son as√≠ncronas y no bloquean
  - Los tokens JWT se verifican en cada request
  - El estado de sesi√≥n sigue un flujo estricto:
    requested ‚Üí confirmed ‚Üí done
end note

@enduml
